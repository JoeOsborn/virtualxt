// Copyright (c) 2019-2023 Andreas T Jonsson <mail@andreasjonsson.se>
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software in
//    a product, an acknowledgment (see the following) in the product
//    documentation is required.
//
//    Portions Copyright (c) 2019-2023 Andreas T Jonsson <mail@andreasjonsson.se>
//
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.

#ifndef _ZIP2IMG_H_
#define _ZIP2IMG_H_

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <miniz.h>
#include <fat16.h>

#define MZ_PRINT_ERROR(a) { fprintf(stderr, "miniz error: %s\n", mz_zip_get_error_string(mz_zip_get_last_error(a))); }

FAT16 fat;
BLOCKDEV dev;
FILE *output;

static const unsigned char mbr_41943040[512] = {
    0xFA, 0xFC, 0x31, 0xC0, 0x8E, 0xD0, 0x8E, 0xD8, 0xBD, 0x00, 0x7C, 0x8D, 0x66, 0xE0, 0xFB, 0xB8, 
    0xE0, 0x1F, 0x8E, 0xC0, 0x89, 0xEE, 0x89, 0xEF, 0xB9, 0x00, 0x01, 0xF3, 0xA5, 0xEA, 0x22, 0x7C, 
    0xE0, 0x1F, 0x8E, 0xD8, 0x8E, 0xD0, 0x31, 0xC0, 0x8E, 0xC0, 0x8D, 0xBE, 0xBE, 0x01, 0xF6, 0x05, 
    0x80, 0x75, 0x6D, 0x83, 0xC7, 0x10, 0x81, 0xFF, 0xFE, 0x7D, 0x72, 0xF2, 0xE8, 0xC4, 0x00, 0x6E, 
    0x6F, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 
    0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x00, 0xEB, 0xFE, 0xE8, 0xA5, 0x00, 0x72, 0x65, 
    0x61, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x72, 
    0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x00, 0xEB, 0xDA, 0xE8, 
    0x81, 0x00, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x69, 0x67, 0x6E, 
    0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x21, 0x3D, 0x20, 0x35, 0x35, 0x41, 0x41, 0x00, 0xEB, 0xB9, 
    0xE8, 0x10, 0x00, 0x72, 0xB6, 0x26, 0x81, 0x3E, 0xFE, 0x7D, 0x55, 0xAA, 0x75, 0xD1, 0xEA, 0x00, 
    0x7C, 0x00, 0x00, 0xBB, 0xAA, 0x55, 0xB4, 0x41, 0xCD, 0x13, 0x72, 0x32, 0x81, 0xFB, 0x55, 0xAA, 
    0x75, 0x2C, 0xF6, 0xC1, 0x01, 0x74, 0x27, 0xEB, 0x10, 0x10, 0x00, 0x04, 0x00, 0x00, 0x7C, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0x08, 0xA3, 0xD1, 0x7C, 0x8B, 
    0x45, 0x0A, 0xA3, 0xD3, 0x7C, 0xB8, 0x00, 0x42, 0xBE, 0xC9, 0x7C, 0xCD, 0x13, 0xC3, 0xB8, 0x04, 
    0x02, 0xBB, 0x00, 0x7C, 0x8B, 0x4D, 0x02, 0x8A, 0x75, 0x01, 0xCD, 0x13, 0xC3, 0x31, 0xDB, 0xB4, 
    0x0E, 0xCD, 0x10, 0x5E, 0xAC, 0x56, 0x3C, 0x00, 0x75, 0xF3, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
    0x01, 0x00, 0x06, 0x0F, 0x3F, 0x4F, 0x3F, 0x00, 0x00, 0x00, 0xC1, 0x3A, 0x01, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};

static void block_seek(const uint32_t pos) {
	fseek(output, pos, SEEK_SET);
}

static void block_rseek(const int16_t pos) {
	fseek(output, pos, SEEK_CUR);
}

static void block_flush(void) {
	fflush(output);
}

static void block_load(void *dest, const uint16_t len) {
	fread(dest, len, 1, output);
}

static void block_store(const void* source, const uint16_t len) {
	fwrite(source, len, 1, output);
}

static void block_write(const uint8_t b) {
	fwrite(&b, 1, 1, output);
}

static uint8_t block_read(void) {
	uint8_t b;
	fread(&b, 1, 1, output);
	return b;
}

static void block_open(const char *file) {
	dev = (BLOCKDEV){
		.read = &block_read,
		.write = &block_write,
		.load = &block_load,
		.store = &block_store,
		.seek = &block_seek,
		.rseek = &block_rseek,
		.flush = &block_flush
	};
	
	output = fopen(file, "wb");
	fwrite(mbr_41943040, 1, 512, output);
	for (int i = 512; i < 41943040; i++)
		fputc(0, output);
	fclose(output);
	//output = fopen(file, "rb+");
	//rewind(output);
	//output = fopen(file, "rb+");
}

static void block_close() {
	fflush(output);
	fclose(output);
}

static bool create_dir(FFILE *file, const char *name) {
	if (!ff_mkdir(file, name)) {
		if (!ff_find(file, name)) {
			fprintf(stderr, "Could not find sub-directory: %s\n", name);
			return false;
		} else if (!ff_opendir(file)) {
			fprintf(stderr, "Could not open sub-directory: %s\n", name);
			return false;
		}
	}
	return true;
}

static char *strupper(char *str) {
	for (int i = 0; i < (int)strlen(str); i++)
		str[i] = toupper(str[i]);
	return str;
}

static bool write_img_file(const char *path, void *data, int size) {
	FFILE file;
	ff_root(&fat, &file);

	char name[13] = {0};
	const char *sub = path;
	char *pch = strchr(path, '/');

	while (pch != NULL) {
		int ln = pch - sub;
		if (ln > 12) {
			fprintf(stderr, "Name of sub-directory is to long: %s\n", path);
			return false;
		}

		strncpy(name, sub, ln);
		name[ln] = 0;
		if (!create_dir(&file, strupper(name)))
			return false;

		sub = pch + 1;
		pch = strchr(pch + 1, '/');
	}

	if (strlen(sub) > 12) {
		fprintf(stderr, "Name of file is to long: %s\n", sub);
		return false;
	}

	strcpy(name, sub);
	if (!ff_newfile(&file, strupper(name))) {
		fprintf(stderr, "Could not ff_newfile\n");
		return false;
	}

	if (!ff_write(&file, data, size)) {
		fprintf(stderr, "Could not ff_write\n");
		return false;
	}

	ff_flush_file(&file);
	return true;
}

static bool do_zip2img(mz_zip_archive *in) {
	int num = mz_zip_reader_get_num_files(in);
    for (int i = 0; i < num; i++) {
		mz_zip_archive_file_stat stat;
		if (!mz_zip_reader_file_stat(in, i, &stat)) {
			MZ_PRINT_ERROR(in);
			return false;
		}

		if (mz_zip_reader_is_file_a_directory(in, i))
			continue;

		size_t sz;
		void *data = mz_zip_reader_extract_file_to_heap(in, stat.m_filename, &sz, 0);
		if (!data) {
			MZ_PRINT_ERROR(in);
			return false;
		}

		bool res = write_img_file(stat.m_filename, data, (int)sz);
		mz_free(data);
		if (!res)
			return false;
	}
	return true;
}

static bool zip2img(const char *in, const char *out) {
	mz_zip_archive ar;
	memset(&ar, 0, sizeof(ar));
	mz_bool status = mz_zip_reader_init_file(&ar, in, 0);
	if (!status) {
		MZ_PRINT_ERROR(&ar);
		return false;
	}

	block_open(out);
	if (!ff_init(&dev, &fat)) {
		fprintf(stderr, "Could not initialize FAT16!\n");
		mz_zip_reader_end(&ar);
		block_close();
		return false;
	}

	bool res = do_zip2img(&ar);
    mz_zip_reader_end(&ar);
	block_close();
	return res;
}

#endif
